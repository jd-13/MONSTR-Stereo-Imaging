/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"

#include "PluginEditor.h"
#include "WEFilters/StereoWidthProcessorParameters.h"

//==============================================================================
MonstrAudioProcessor::MonstrAudioProcessor()
{
    namespace MP = WECore::MONSTR::Parameters;
    namespace SP = WECore::StereoWidth::Parameters;

    constexpr float WIDTH_PRECISION {0.01f};
    constexpr float FREQ_PRECISION {0.001f};

    registerParameter(bandParameters[0].isActive, BAND_STRINGS[0].isActive, MP::BANDSWITCH_DEFAULT, [&](bool val) { setBandActive(0, val); });
    registerParameter(bandParameters[0].width, BAND_STRINGS[0].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION, [&](float val) { setBandWidth(0, val); });
    registerParameter(crossoverParameters[0], CROSSOVER_STRINGS[0], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_LOWER_DEFAULT, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(0, val); });

    registerParameter(bandParameters[1].isActive, BAND_STRINGS[1].isActive, MP::BANDSWITCH_DEFAULT, [&](bool val) { setBandActive(1, val); });
    registerParameter(bandParameters[1].width, BAND_STRINGS[1].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION, [&](float val) { setBandWidth(1, val); });
    registerParameter(crossoverParameters[1], CROSSOVER_STRINGS[1], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_UPPER_DEFAULT, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(1, val); });

    registerParameter(bandParameters[2].isActive, BAND_STRINGS[2].isActive, MP::BANDSWITCH_DEFAULT, [&](bool val) { setBandActive(2, val); });
    registerParameter(bandParameters[2].width, BAND_STRINGS[2].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION, [&](float val) { setBandWidth(2, val); });
    registerParameter(crossoverParameters[2], CROSSOVER_STRINGS[2], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_FREQUENCY.defaultValue, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(2, val); });

    registerParameter(bandParameters[3].isActive, BAND_STRINGS[3].isActive, MP::BANDSWITCH_DEFAULT, [&](bool val) { setBandActive(3, val); });
    registerParameter(bandParameters[3].width, BAND_STRINGS[3].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION, [&](float val) { setBandWidth(3, val); });
    registerParameter(crossoverParameters[3], CROSSOVER_STRINGS[3], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_FREQUENCY.defaultValue, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(3, val); });

    registerParameter(bandParameters[4].isActive, BAND_STRINGS[4].isActive, MP::BANDSWITCH_DEFAULT, [&](bool val) { setBandActive(4, val); });
    registerParameter(bandParameters[4].width, BAND_STRINGS[4].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION, [&](float val) { setBandWidth(4, val); });
    registerParameter(crossoverParameters[4], CROSSOVER_STRINGS[4], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_FREQUENCY.defaultValue, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(4, val); });

    registerParameter(bandParameters[5].isActive, BAND_STRINGS[5].isActive, MP::BANDSWITCH_DEFAULT, [&](bool val) { setBandActive(5, val); });
    registerParameter(bandParameters[5].width, BAND_STRINGS[5].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION, [&](float val) { setBandWidth(5, val); });

    // New parameters must be registered last to preserve backwards compatibility
    registerParameter(bandParameters[0].isMuted, BAND_STRINGS[0].isMuted, MP::BANDMUTED_DEFAULT, [&](bool val) { setBandMuted(0, val); });
    registerParameter(bandParameters[0].isSoloed, BAND_STRINGS[0].isSoloed, MP::BANDSOLO_DEFAULT, [&](bool val) { setBandSoloed(0, val); });

    registerParameter(bandParameters[1].isMuted, BAND_STRINGS[1].isMuted, MP::BANDMUTED_DEFAULT, [&](bool val) { setBandMuted(1, val); });
    registerParameter(bandParameters[1].isSoloed, BAND_STRINGS[1].isSoloed, MP::BANDSOLO_DEFAULT, [&](bool val) { setBandSoloed(1, val); });

    registerParameter(bandParameters[2].isMuted, BAND_STRINGS[2].isMuted, MP::BANDMUTED_DEFAULT, [&](bool val) { setBandMuted(2, val); });
    registerParameter(bandParameters[2].isSoloed, BAND_STRINGS[2].isSoloed, MP::BANDSOLO_DEFAULT, [&](bool val) { setBandSoloed(2, val); });

    registerParameter(bandParameters[3].isMuted, BAND_STRINGS[3].isMuted, MP::BANDMUTED_DEFAULT, [&](bool val) { setBandMuted(3, val); });
    registerParameter(bandParameters[3].isSoloed, BAND_STRINGS[3].isSoloed, MP::BANDSOLO_DEFAULT, [&](bool val) { setBandSoloed(3, val); });

    registerParameter(bandParameters[4].isMuted, BAND_STRINGS[4].isMuted, MP::BANDMUTED_DEFAULT, [&](bool val) { setBandMuted(4, val); });
    registerParameter(bandParameters[4].isSoloed, BAND_STRINGS[4].isSoloed, MP::BANDSOLO_DEFAULT, [&](bool val) { setBandSoloed(4, val); });
    
    registerParameter(bandParameters[5].isMuted, BAND_STRINGS[5].isMuted, MP::BANDMUTED_DEFAULT, [&](bool val) { setBandMuted(5, val); });
    registerParameter(bandParameters[5].isSoloed, BAND_STRINGS[5].isSoloed, MP::BANDSOLO_DEFAULT, [&](bool val) { setBandSoloed(5, val); });

    auto restoreBands = [&](int val) {
        mMONSTR.mCrossover.setNumBands(val);
        numBands->setValueNotifyingHost(numBands->getNormalisableRange().convertTo0to1(mMONSTR.mCrossover.getNumBands()));
        _refreshCrossoverParameters();
    };

    registerParameter(numBands, NUMBANDS_STR, &MP::NUM_BANDS, MP::NUM_BANDS.defaultValue, restoreBands);

}

MonstrAudioProcessor::~MonstrAudioProcessor()
{
}

//==============================================================================
const String MonstrAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String MonstrAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String MonstrAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool MonstrAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool MonstrAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool MonstrAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool MonstrAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool MonstrAudioProcessor::silenceInProducesSilenceOut() const
{
    return true;
}

double MonstrAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int MonstrAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int MonstrAudioProcessor::getCurrentProgram()
{
    return 0;
}

void MonstrAudioProcessor::setCurrentProgram (int index)
{
}

const String MonstrAudioProcessor::getProgramName (int index)
{
    return String();
}

void MonstrAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void MonstrAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    mMONSTR.mCrossover.reset();
    // initialisation that you need..
}

void MonstrAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void MonstrAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i) {
        buffer.clear (i, 0, buffer.getNumSamples());
    }

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    float* inLeftSample {buffer.getWritePointer(0)};
    float* inRightSample {buffer.getWritePointer(1)};

    mMONSTR.setSampleRate(getSampleRate());

    mMONSTR.Process2in2out(inLeftSample, inRightSample, buffer.getNumSamples());
}

//==============================================================================
bool MonstrAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* MonstrAudioProcessor::createEditor()
{
    return new MonstrAudioProcessorEditor (*this);
}

//==============================================================================
void MonstrAudioProcessor::addBand() {
    mMONSTR.mCrossover.addBand();
    numBands->setValueNotifyingHost(numBands->getNormalisableRange().convertTo0to1(mMONSTR.mCrossover.getNumBands()));

    // The crossover may rearrange some crossover frequencies to make the new band fit, as well as
    // parameters of the new band having been reset to their defaults - we need to make sure the UI
    // and host parameters are kept in sync
    _refreshCrossoverParameters();
}
void MonstrAudioProcessor::removeBand() {
    mMONSTR.mCrossover.removeBand();
    numBands->setValueNotifyingHost(numBands->getNormalisableRange().convertTo0to1(mMONSTR.mCrossover.getNumBands()));
}

void MonstrAudioProcessor::setBandActive(size_t index, bool val) {
    if (index < bandParameters.size()) {
        mMONSTR.mCrossover.setIsActive(index, val);
        bandParameters[index].isActive->setValueNotifyingHost(val);
    }
}

void MonstrAudioProcessor::setBandMuted(size_t index, bool val) {
    if (index < bandParameters.size()) {
        mMONSTR.mCrossover.setIsMuted(index, val);
        bandParameters[index].isMuted->setValueNotifyingHost(val);
    }
}

void MonstrAudioProcessor::setBandSoloed(size_t index, bool val) {
    if (index < bandParameters.size()) {
        mMONSTR.mCrossover.setIsSoloed(index, val);
        bandParameters[index].isSoloed->setValueNotifyingHost(val);
    }
}

void MonstrAudioProcessor::setBandWidth(size_t index, float val) {
    if (index < bandParameters.size()) {
        mMONSTR.processors[index]->setWidth(WECore::StereoWidth::Parameters::WIDTH.NormalisedToInternal(val));
        bandParameters[index].width->setValueNotifyingHost(val);
    }
}

void MonstrAudioProcessor::setCrossoverFrequency(size_t index, float val) {
    if (index < crossoverParameters.size()) {
        mMONSTR.mCrossover.setCrossoverFrequency(index, WECore::MONSTR::Parameters::CROSSOVER_FREQUENCY.NormalisedToInternal(val));
        crossoverParameters[index]->setValueNotifyingHost(val);

        // Changing the frequency of one crossover may affect others if they also need to be moved -
        // make sure the UI and host parameters are updated
        _refreshCrossoverParameters();
    }
}

void MonstrAudioProcessor::_refreshCrossoverParameters() {
    for (size_t index {0}; index < mMONSTR.mCrossover.getNumBands() - 1; index++) {

        const double normalisedFrequency {
            WECore::MONSTR::Parameters::CROSSOVER_FREQUENCY.InternalToNormalised(
                mMONSTR.mCrossover.getCrossoverFrequency(index))
        };

        crossoverParameters[index]->setValueNotifyingHost(normalisedFrequency);
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MonstrAudioProcessor();
}
