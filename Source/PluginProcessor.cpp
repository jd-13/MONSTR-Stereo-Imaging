/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"

#include "PluginEditor.h"
#include "WEFilters/StereoWidthProcessorParameters.h"

//==============================================================================
MonstrAudioProcessor::MonstrAudioProcessor()
{
    namespace MP = WECore::MONSTR::Parameters;
    namespace SP = WECore::StereoWidth::Parameters;

    constexpr float WIDTH_PRECISION {0.01f};
    constexpr float FREQ_PRECISION {0.0001f};

    // numBands must be restored first (otherwise we can't set the band parameters)
    auto restoreBands = [&](int val) {
        mMONSTR.mCrossover.setNumBands(val);
        numBands->setValueNotifyingHost(numBands->getNormalisableRange().convertTo0to1(mMONSTR.mCrossover.getNumBands()));
        _refreshCrossoverParameters();
    };

    registerPrivateParameter(numBands, NUMBANDS_STR, &MP::NUM_BANDS, MP::NUM_BANDS.defaultValue, restoreBands);

    registerParameter(bandParameters[0].isActive, BAND_STRINGS[0].isActive, MP::BANDSWITCH_DEFAULT);
    registerParameter(bandParameters[0].isMuted, BAND_STRINGS[0].isMuted, MP::BANDMUTED_DEFAULT);
    registerParameter(bandParameters[0].isSoloed, BAND_STRINGS[0].isSoloed, MP::BANDSOLO_DEFAULT);
    registerParameter(bandParameters[0].width, BAND_STRINGS[0].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION);
    registerPrivateParameter(crossoverParameters[0], CROSSOVER_STRINGS[0], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_LOWER_DEFAULT, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(0, val); });

    registerParameter(bandParameters[1].isActive, BAND_STRINGS[1].isActive, MP::BANDSWITCH_DEFAULT);
    registerParameter(bandParameters[1].isMuted, BAND_STRINGS[1].isMuted, MP::BANDMUTED_DEFAULT);
    registerParameter(bandParameters[1].isSoloed, BAND_STRINGS[1].isSoloed, MP::BANDSOLO_DEFAULT);
    registerParameter(bandParameters[1].width, BAND_STRINGS[1].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION);
    registerPrivateParameter(crossoverParameters[1], CROSSOVER_STRINGS[1], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_UPPER_DEFAULT, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(1, val); });

    registerParameter(bandParameters[2].isActive, BAND_STRINGS[2].isActive, MP::BANDSWITCH_DEFAULT);
    registerParameter(bandParameters[2].isMuted, BAND_STRINGS[2].isMuted, MP::BANDMUTED_DEFAULT);
    registerParameter(bandParameters[2].isSoloed, BAND_STRINGS[2].isSoloed, MP::BANDSOLO_DEFAULT);
    registerParameter(bandParameters[2].width, BAND_STRINGS[2].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION);
    registerPrivateParameter(crossoverParameters[2], CROSSOVER_STRINGS[2], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_FREQUENCY.defaultValue, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(2, val); });

    registerParameter(bandParameters[3].isActive, BAND_STRINGS[3].isActive, MP::BANDSWITCH_DEFAULT);
    registerParameter(bandParameters[3].isMuted, BAND_STRINGS[3].isMuted, MP::BANDMUTED_DEFAULT);
    registerParameter(bandParameters[3].isSoloed, BAND_STRINGS[3].isSoloed, MP::BANDSOLO_DEFAULT);
    registerParameter(bandParameters[3].width, BAND_STRINGS[3].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION);
    registerPrivateParameter(crossoverParameters[3], CROSSOVER_STRINGS[3], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_FREQUENCY.defaultValue, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(3, val); });

    registerParameter(bandParameters[4].isActive, BAND_STRINGS[4].isActive, MP::BANDSWITCH_DEFAULT);
    registerParameter(bandParameters[4].isMuted, BAND_STRINGS[4].isMuted, MP::BANDMUTED_DEFAULT);
    registerParameter(bandParameters[4].isSoloed, BAND_STRINGS[4].isSoloed, MP::BANDSOLO_DEFAULT);
    registerParameter(bandParameters[4].width, BAND_STRINGS[4].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION);
    registerPrivateParameter(crossoverParameters[4], CROSSOVER_STRINGS[4], &MP::CROSSOVER_FREQUENCY, MP::CROSSOVER_FREQUENCY.defaultValue, FREQ_PRECISION, [&](float val) { setCrossoverFrequency(4, val); });

    registerParameter(bandParameters[5].isActive, BAND_STRINGS[5].isActive, MP::BANDSWITCH_DEFAULT);
    registerParameter(bandParameters[5].isMuted, BAND_STRINGS[5].isMuted, MP::BANDMUTED_DEFAULT);
    registerParameter(bandParameters[5].isSoloed, BAND_STRINGS[5].isSoloed, MP::BANDSOLO_DEFAULT);
    registerParameter(bandParameters[5].width, BAND_STRINGS[5].width, &SP::WIDTH, SP::WIDTH.defaultValue, WIDTH_PRECISION);
}

MonstrAudioProcessor::~MonstrAudioProcessor()
{
}

//==============================================================================
const String MonstrAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String MonstrAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String MonstrAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool MonstrAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool MonstrAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool MonstrAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool MonstrAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool MonstrAudioProcessor::silenceInProducesSilenceOut() const
{
    return true;
}

double MonstrAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int MonstrAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int MonstrAudioProcessor::getCurrentProgram()
{
    return 0;
}

void MonstrAudioProcessor::setCurrentProgram (int index)
{
}

const String MonstrAudioProcessor::getProgramName (int index)
{
    return String();
}

void MonstrAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void MonstrAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    mMONSTR.mCrossover.reset();
    // initialisation that you need..
}

void MonstrAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void MonstrAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i) {
        buffer.clear (i, 0, buffer.getNumSamples());
    }

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    float* inLeftSample {buffer.getWritePointer(0)};
    float* inRightSample {buffer.getWritePointer(1)};

    mMONSTR.setSampleRate(getSampleRate());

    mMONSTR.Process2in2out(inLeftSample, inRightSample, buffer.getNumSamples());
}

//==============================================================================
bool MonstrAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* MonstrAudioProcessor::createEditor()
{
    return new MonstrAudioProcessorEditor (*this);
}

//==============================================================================
void MonstrAudioProcessor::addBand() {
    mMONSTR.mCrossover.addBand();
    numBands->setValueNotifyingHost(numBands->getNormalisableRange().convertTo0to1(mMONSTR.mCrossover.getNumBands()));

    // The crossover may rearrange some crossover frequencies to make the new band fit, as well as
    // parameters of the new band having been reset to their defaults - we need to make sure the UI
    // and host parameters are kept in sync
    _refreshCrossoverParameters();
}
void MonstrAudioProcessor::removeBand() {
    mMONSTR.mCrossover.removeBand();
    numBands->setValueNotifyingHost(numBands->getNormalisableRange().convertTo0to1(mMONSTR.mCrossover.getNumBands()));
}

void MonstrAudioProcessor::setCrossoverFrequency(size_t index, float val) {
    if (index < mMONSTR.mCrossover.getNumBands() - 1) {
        mMONSTR.mCrossover.setCrossoverFrequency(index, val);

        // Changing the frequency of one crossover may affect others if they also need to be moved -
        // make sure the UI and host parameters are updated
        _refreshCrossoverParameters();
    }
}

double MonstrAudioProcessor::getProcessedWidthValue(size_t index) const {
    double retVal {0};

    if (index < bandParameters.size()) {
        retVal = mMONSTR.processors[index]->getProcessedWidthValue();
    }

    return retVal;
}

void MonstrAudioProcessor::_refreshCrossoverParameters() {
    for (size_t index {0}; index < mMONSTR.mCrossover.getNumBands() - 1; index++) {

        const double normalisedFrequency {
            WECore::MONSTR::Parameters::CROSSOVER_FREQUENCY.InternalToNormalised(
                mMONSTR.mCrossover.getCrossoverFrequency(index))
        };

        crossoverParameters[index]->setValueNotifyingHost(normalisedFrequency);
    }
}

std::vector<juce::String> MonstrAudioProcessor::_provideParamNamesForMigration() {
    return std::vector<juce::String> {
        BAND_STRINGS[0].isActive,
        BAND_STRINGS[0].width,
        CROSSOVER_STRINGS[0],

        BAND_STRINGS[1].isActive,
        BAND_STRINGS[1].width,
        CROSSOVER_STRINGS[1],

        BAND_STRINGS[2].isActive,
        BAND_STRINGS[2].width
    };
}

void MonstrAudioProcessor::_migrateParamValues(std::vector<float>& paramValues) {
    if (paramValues.size() == 8) {
        const ParameterDefinition::RangedParameter<double> CROSSOVERLOWER(40, 500, 100);
        const ParameterDefinition::RangedParameter<double> CROSSOVERUPPER(3000, 19500, 5000);

        paramValues[1] = WECore::StereoWidth::Parameters::WIDTH.NormalisedToInternal(paramValues[1]);
        paramValues[2] = CROSSOVERLOWER.NormalisedToInternal(paramValues[2]);

        paramValues[4] = WECore::StereoWidth::Parameters::WIDTH.NormalisedToInternal(paramValues[4]);
        paramValues[5] = CROSSOVERUPPER.NormalisedToInternal(paramValues[5]);

        paramValues[7] = WECore::StereoWidth::Parameters::WIDTH.NormalisedToInternal(paramValues[7]);
    }
}

void MonstrAudioProcessor::_onParameterUpdate() {

    for (size_t index {0}; index < mMONSTR.mCrossover.getNumBands(); index++) {
        mMONSTR.mCrossover.setIsActive(index, bandParameters[index].isActive->get());
        mMONSTR.mCrossover.setIsMuted(index, bandParameters[index].isMuted->get());
        mMONSTR.mCrossover.setIsSoloed(index, bandParameters[index].isSoloed->get());
        mMONSTR.processors[index]->setWidth(bandParameters[index].width->get());
    }

    // We can't update the crossover frequencies here, as we would need to call
    // _refreshCrossoverParameters() which would cause this to be called again, which would call
    // _refreshCrossoverParameters() again, etc
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MonstrAudioProcessor();
}
